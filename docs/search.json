[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Let’s combine GRASS, Python and R",
    "section": "",
    "text": "Traditionally, species distribution models (SDM) use climatic data as predictors of habitat suitability for the target species. In this studio, we will explore the use of satellite data to derive relevant predictors. The satellite data processing, from download to analysis, will be performed using GRASS GIS software functionality. Then, we’ll read our predictors within R and perform SDM, visualize and analyze results there, to then exemplify how to write the output distribution maps back into GRASS."
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Let’s combine GRASS, Python and R",
    "section": "Software",
    "text": "Software\nIf you still want to run the workshop locally, you’ll find instructions and requirements below.\n\nGRASS GIS\nWe will use GRASS GIS 8.3+. It can be installed either through standalone installers/binaries or through OSGeo-Live (a linux based virtual machine which includes all OSGeo software and packages).\n\nMS Windows\nFor Windows users, we strongly recommend installing GRASS GIS through the OSGeo4W package, since it allows to install all OSGeo software and resolves dependencies.\n\n\nUbuntu Linux\nInstall GRASS GIS 8.3+ from the “unstable” package repository:\n  sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\n  sudo apt-get update\n  sudo apt-get install grass grass-gui grass-dev\n\n\nFedora, openSuSe Linux\nFor other Linux distributions including Fedora and openSuSe, simply install GRASS GIS with the respective package manager. See also here\n\n\nMac OS\nFind GRASS GIS binaries on http://grassmac.wikidot.com/ or install the latest available version from MacPorts.\n\n\nGRASS GIS Add-ons\n\nr.bioclim: Calculates bioclimatic indices as those in WorldClim.\n\nInstall with g.extension extension=name_of_addon\n\n\n\nR packages\nThe following R packages should be installed beforehand:\n  install.packages(c(\"rgrass\",\"terra\",\"sf\",\"mapview\",\"biomod2\",\"dismo\",\"usdm\",\"SDMtune\",\"zeallot\",\"rJava\",\"ggpubr\"))\n\n\nPython libraries\nThe following Python libraries should be installed beforehand:\n  pip install folium"
  },
  {
    "objectID": "index.html#other-software",
    "href": "index.html#other-software",
    "title": "Let’s combine GRASS, Python and R",
    "section": "Other software",
    "text": "Other software\nWe will use the software MaxEnt to model habitat suitability. It can be downloaded from: https://biodiversityinformatics.amnh.org/open_source/maxent/"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Let’s combine GRASS, Python and R",
    "section": "Data",
    "text": "Data\nDownload the following ready to use project with reconstructed daily LST averages (Metz et al. (2017)) for Northern Italy. This dataset is courtesy of mundialis GmbH & Co. KG.\n\nNorthern Italy (1.7 Gb)\n\nWe will also use a points vector map representing Aedes albopictus presence data:\n\nMosquito occurrence data"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Let’s combine GRASS, Python and R",
    "section": "References",
    "text": "References\n\n\nMetz, M., Andreo, V., and Neteler, M. (2017), “A New Fully Gap-Free Time Series of Land Surface Temperature from MODIS LST Data,” Remote Sensing, 9, 1333. https://doi.org/10.3390/rs9121333.\n\n\n\n\n\n\n\n\n\n\n:::"
  },
  {
    "objectID": "notebook_ex_sdm_r.html",
    "href": "notebook_ex_sdm_r.html",
    "title": "Part 2: Modelling with R",
    "section": "",
    "text": "In this third part of the workshop, we’ll use R to model Aedes albopictus distribution in Northern Italy. For that, we need to connect to GRASS via the rgrass package in order to read occurrence data and predictors. The rgrass package is maintained by Bivand (2022) and can be found at: https://github.com/rsbivand/rgrass/. See the vignette with further explanations and examples at: https://rsbivand.github.io/rgrass/."
  },
  {
    "objectID": "notebook_ex_sdm_r.html#usage",
    "href": "notebook_ex_sdm_r.html#usage",
    "title": "Part 2: Modelling with R",
    "section": "Usage",
    "text": "Usage\nWe will start GRASS GIS within an R session, i.e. we connect to a GRASS project from within R (or RStudio). The steps are as follows:\n\nstart GRASS GIS with initGRASS() from R\nexecute GRASS GIS tools through execGRASS()\n\nuse read_VECT(), read_RAST(), write_VECT() and write_RAST() to read data from and to GRASS database\n\n\n\n\n\n\n\nNote\n\n\n\nrgrass was originally intended to apply GRASS functions on data outside GRASS projects; hence some prefer to create temporary projects."
  },
  {
    "objectID": "notebook_ex_sdm_r.html#references",
    "href": "notebook_ex_sdm_r.html#references",
    "title": "Part 2: Modelling with R",
    "section": "References",
    "text": "References\n\n\nBivand, R. (2022), Rgrass: Interface between ’GRASS’ geographical information system and ’r’.\n\n\nVignali, S., Barras, A. G., Arlettaz, R., and Braunisch, V. (2020), “SDMtune: An r package to tune and evaluate species distribution models,” Ecology and Evolution, 00, 1–18. https://doi.org/10.1002/ece3.6786.\n\n\n\n:::"
  },
  {
    "objectID": "notebook_ex_rs_grass.html",
    "href": "notebook_ex_rs_grass.html",
    "title": "Part 1: Processing data in GRASS",
    "section": "",
    "text": "In this notebook we’ll go through the processing of MODIS LST daily time series data to derive relevant predictor variables for modeling the distribution of Aedes albopictus in Northern Italy. Furthermore, we’ll show how to obtain and process occurrence data and background points.\nLet’s first go through some temporal concepts within GRASS GIS…"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#the-tgrass-framework",
    "href": "notebook_ex_rs_grass.html#the-tgrass-framework",
    "title": "Part 1: Processing data in GRASS",
    "section": "The TGRASS framework",
    "text": "The TGRASS framework\nGRASS GIS was the first FOSS GIS that incorporated capabilities to manage, analyze, process and visualize spatio-temporal data, as well as the temporal relationships among time series.\n\nTGRASS is fully based on metadata and does not duplicate any dataset\nSnapshot approach, i.e., adds time stamps to maps\nA collection of time stamped maps (snapshots) of the same variable are called space-time datasets or STDS\nMaps in a STDS can have different spatial and temporal extents\nSpace-time datasets can be composed of raster, raster 3D or vector maps, and so we call them:\n\nSpace time raster datasets (STRDS)\nSpace time 3D raster datasets (STR3DS)\nSpace time vector datasets (STVDS)"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#temporal-modules",
    "href": "notebook_ex_rs_grass.html#temporal-modules",
    "title": "Part 1: Processing data in GRASS",
    "section": "Temporal modules",
    "text": "Temporal modules\nGRASS temporal modules are named and organized following GRASS core naming scheme. In this way, we have:\n\nt.*: General modules to handle STDS of all types\nt.rast.*: Modules that deal with STRDS\nt.rast3d.*: Modules that deal with STR3DS\nt.vect.*: Modules that deal with STVDS\n\n\nOther TGRASS notions\n\nTime can be defined as intervals (start and end time) or instances (only start time)\nTime can be absolute (e.g., 2017-04-06 22:39:49) or relative (e.g., 4 years, 90 days)\nGranularity is the greatest common divisor of the temporal extents (and possible gaps) of all maps in the space-time cube\n\n\n\n\n\n\n\nTopology refers to temporal relations between time intervals in a STDS.\n\n\n\n\n\n\n\n\nTGRASS framework and workflow"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#grass",
    "href": "notebook_ex_rs_grass.html#grass",
    "title": "Part 1: Processing data in GRASS",
    "section": "GRASS + ",
    "text": "GRASS + \nIn this part of the studio we’ll work with GRASS and Python, so let’s first see/recall the very basics.\n\nPython package grass.script\nThe grass.script or GRASS GIS Python Scripting Library provides functions for calling GRASS tools within Python scripts. The most commonly used functions include:\n\nrun_command: used when the output of the tools is a raster or vector, no text type output is expected\nread_command: used when the output of the tools is of text type\nparse_command: used with tools whose output can be converted to key=value pairs\nwrite_command: used with tools that expect text input, either in the form of a file or from standard input\n\nIt also provides several wrapper functions for frequently used tools, for example:\n\nTo get info from a raster, script.raster.raster_info() is used: gs.raster_info('dsm')\nTo get info of a vector, script.vector.vector_info() is used: gs.vector_info('roads')\nTo list the raster in a project, script.core.list_grouped() is used: gs.list_grouped(type=['raster'])\nTo obtain the computational region, script.core.region() is used: gs.region()\n\n\n\n\n\n\n\nNote\n\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html\n\n\n\n\nPython package grass.jupyter\nThe grass.jupyter library improves the integration of GRASS and Jupyter, and provides different classes to facilitate GRASS maps visualization:\n\ninit: starts a GRASS session and sets up all necessary environment variables\nMap: 2D rendering\nMap3D: 3D rendering\nInteractiveMap: interactive visualization with folium\nSeriesMap: visualizations for a series of raster or vector maps\nTimeSeriesMap: visualization for spatio-temporal data\n\n\n\n\n\n\n\nNote\n\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#hands-on",
    "href": "notebook_ex_rs_grass.html#hands-on",
    "title": "Part 1: Processing data in GRASS",
    "section": "Hands-on",
    "text": "Hands-on\nSo let’s start… We begin by setting variables, checking GRASS installation and initializing GRASS GIS\n\nimport os\n\n# Data directory\nhomedir = os.path.join(os.path.expanduser('~'), \"grass_ncsu_2023\")\n\n# GRASS GIS database variables\n#grassbin = \"grass-dev\"\ngrassbin = \"grass\"\ngrassdata = os.path.join(homedir, \"grassdata\")\nproject = \"eu_laea\"\nmapset = \"italy_LST_daily\"\n\n\n# Check the GRASS GIS installation\nimport subprocess\nprint(subprocess.check_output([grassbin, \"--config\", \"version\"], text=True))\n\n\n# Ask GRASS GIS where its Python packages are \nimport sys\nsys.path.append(\n    subprocess.check_output([grassbin, \"--config\", \"python_path\"], text=True).strip()\n)\n\nNow we are ready to start a GRASS GIS session\n\n# Import the GRASS GIS packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Start the GRASS GIS Session\nsession = gj.init(grassdata, project, mapset)\n\n\nExplore data in the mapset\nLet’s first explore what we have within the italy_LST_daily mapset and display vector and raster maps using different classes from grass.jupyter library.\n\n# List vector elements\ngs.list_grouped(type=\"vector\")['italy_LST_daily']\n\n\n# Display vector map\nit_map = gj.Map(width=500, use_region=True)\nit_map.d_vect(map=\"italy_borders_0\")\nit_map.show()\n\n\n# List raster elements\nrast = gs.list_grouped(type=\"raster\", pattern=\"lst*\")['italy_LST_daily']\nrast[0:10]\n\n\n# Display raster map with interactive class\nlst_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlst_map.add_raster(\"lst_2014.005_avg\")\nlst_map.add_layer_control(position = \"bottomright\")\nlst_map.show()"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#sdm-workflow",
    "href": "notebook_ex_rs_grass.html#sdm-workflow",
    "title": "Part 1: Processing data in GRASS",
    "section": "SDM workflow",
    "text": "SDM workflow\nIn this part of the Studio we’ll be addressing the left part of the SDM workflow, occurrence and background data and predictors:\n\n\nImporting species records\nWe will use occurrence data already downloaded and cleaned. We need to import it into GRASS GIS first.\n\n# Import mosquito records\ngs.run_command(\"v.import\",\n               input=os.path.join(homedir,\"aedes_albopictus.gpkg\"),\n               output=\"aedes_albopictus\")\n\nLet’s add the occurrence points over the previous interactive map\n\n# Display raster map with interactive class\nlst_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlst_map.add_raster(\"lst_2014.005_avg\")\nlst_map.add_vector(\"aedes_albopictus\")\nlst_map.add_layer_control(position = \"bottomright\")\nlst_map.show()\n\nYou can also get the mosquito occurrences (or any other species or taxa) directly from GBIF into GRASS by means of v.in.pygbif as follows:\n\n# Set computational region\n# region = gs.parse_command(\"g.region\", raster=\"lst_2014.001_avg\", flags=\"g\")\n# region\n\n\n# Install extension (requires pygbif: pip install pygbif)\n# gs.run_command(\"g.extension\",\n#                extension=\"v.in.pygbif\")\n\n\n# Import data from GBIF\n# gs.run_command(\"v.in.pygbif\", \n#                output=\"aedes_albopictus\",\n#                taxa=\"Aedes albopictus\",\n#                date_from=\"2014-01-01\",\n#                date_to=\"2018-12-31\")\n\n\n\nCreating random background points\nThe algorithm MaxEnt that we will use in the next part of this session requires not only the projects of known occurrences, but also information on the rest of the environment available. These are not absences but background data, we actually do not know if the species is there or not, but we need it to compare with the features of the places where the species does occur.\nTo avoid getting background points exactly where occurrences are, we’ll create buffers around them. Then, we need to ensure that background points are only over land within our computational region. In order to do that, we’ll create a mask over land and we’ll overlay the buffers with the mask. Can you guess what the output will be?\n\n# Create buffer around Aedes albopictus records\ngs.run_command(\"v.buffer\",\n               input=\"aedes_albopictus\",\n               output=\"aedes_buffer\",\n               distance=2000)\n\n\n# Set computational region\nregion = gs.parse_command(\"g.region\", raster=\"lst_2014.001_avg\", flags=\"g\")\nregion\n\n\n# Create a vector mask to limit background points\nexpression=\"MASK = if(lst_2014.001_avg, 1, null())\"\ngs.raster.mapcalc(exp=expression)\n\ngs.run_command(\"r.to.vect\", \n               input=\"MASK\",\n               output=\"vect_mask\",\n               type=\"area\")\n\n\n# Subtract buffers from vector mask\ngs.run_command(\"v.overlay\",\n               ainput=\"vect_mask\",\n               binput=\"aedes_buffer\",\n               operator=\"xor\",\n               output=\"mask_bg\")\n\nLet’s display the result\n\n# Display raster map with interactive class\nmask_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nmask_map.add_vector(\"mask_bg\")\nmask_map.add_layer_control(position = \"bottomright\")\nmask_map.show()\n\nFinally, let’s create the random background points…\n\n# Generate random background points\ngs.run_command(\"v.random\",\n               output=\"background_points\",\n               npoints=1000,\n               restrict=\"mask_bg\",\n               seed=3749)\n\nand display occurrence and background points together over an LST map.\n\n# Display vector map\npb_map = gj.Map(width=500, use_region=True)\npb_map.d_rast(map=\"lst_2014.005_avg\")\npb_map.d_vect(map=\"italy_borders_0\", type=\"boundary\")\npb_map.d_vect(map=\"background_points\")\npb_map.d_vect(map=\"aedes_albopictus\", icon=\"basic/diamond\", fill_color=\"red\", size=8)\npb_map.show()\n\n\n\nCreate daily LST time series\nNow we’ll start processing the raster data to derive potentially relevant predictors to include in the model. Our data consists of a time series of daily LST averages. We’ll use the GRASS temporal framework. The first step is to create the time series object and register maps in it. See t.create and t.register for further details.\n\n# Create time series \ngs.run_command(\"t.create\",\n               type=\"strds\",\n               temporaltype=\"absolute\",\n               output=\"lst_daily\",\n               title=\"Average Daily LST\",\n               description=\"Average daily LST in degree C - 2014-2018\")\n\n\n# Check it is created\ngs.run_command(\"t.list\",\n              type=\"strds\")\n\n\n# Get list of maps \nmap_list = gs.list_grouped(type=\"raster\", pattern=\"lst_201*\")['italy_LST_daily']\nmap_list[0:10]\n\n\n# Register maps in strds  \ngs.run_command(\"t.register\", \n               input=\"lst_daily\",\n               maps=map_list,\n               increment=\"1 days\",\n               start=\"2014-01-01\", \n               flags=\"i\")\n\n\n# Get info about the strds\ngs.run_command(\"t.info\",\n               input=\"lst_daily\")\n\n\n\nGenerate environmental variables from LST STRDS\nNow that we created the time series or STRDS, let’s start estimating relevant variables. We start by calculating long term aggregations, also called climatologies.\n\nLong term monthly avg, min and max LST\nLet’s see an example first; we’ll estimate the average of all maps which start date is within January.\n\n# January average LST\ngs.run_command(\"t.rast.series\",\n               input=\"lst_daily\",\n               method=\"average\",\n               where=\"strftime('%m', start_time)='01'\",\n               output=\"lst_average_jan\")\n\n\n# Get map info and check values\ngs.raster_info(\"lst_average_jan\")['min'], gs.raster_info(\"lst_average_jan\")['max']\n\nIf we want to estimate climatologies for all months, let’s try first to get the list of maps that will be the input for t.rast.series, for that we’ll test the condition in t.rast.list first.\n\n# Define list of months as required\nmonths=['{0:02d}'.format(m) for m in range(1,13)]\n\nfor m in months:\n    gs.run_command(\"t.rast.list\",\n                   input=\"lst_daily\",\n                   where=f\"strftime('%m', start_time)='{m}'\")\n\nNow we add the methods and we are ready to estimate climatologies for all months with three different methods.\n\n# Now we estimate the climatologies for all months and methods\nmonths=['{0:02d}'.format(m) for m in range(1,13)]\nmethods=[\"average\",\"minimum\",\"maximum\"]\n\nfor m in months:\n    for me in methods:\n        gs.run_command(\"t.rast.series\", \n                       input=\"lst_daily\",\n                       method=me,\n                       where=f\"strftime('%m', start_time)='{m}'\",\n                       output=\"lst_{}_{}\".format(me,m))\n\n\n# List newly created maps\nmap_list = gs.list_grouped(type=\"raster\", pattern=\"*{average,minimum,maximum}*\")['italy_LST_daily']\nprint(map_list)\n\n\n# Remove lst_average_jan\ngs.run_command(\"g.remove\", type=\"raster\", name=\"lst_average_jan\", flags=\"f\")\n\n\n\nBioclimatic variables\nPerhaps you have heard of Worldclim or CHELSA bioclimatic variables? Well, this are 19 variables that represent potentially limiting conditions for species. They derive from the combination of temperature and precipitation long term averages. As we do not have precipitation data in this exercise, we’ll only estimate the bioclimatic variables that include temperature. See r.bioclim manual for further details. Note that we’ll use the climatologies estimated in the previous step.\n\n# Install extension\ngs.run_command(\"g.extension\",\n               extension=\"r.bioclim\")\n\n\n# Get lists of maps needed\ntmin=gs.list_grouped(type=\"raster\", pattern=\"lst_minimum_??\")['italy_LST_daily']\ntmax=gs.list_grouped(type=\"raster\", pattern=\"lst_maximum_??\")['italy_LST_daily']\ntavg=gs.list_grouped(type=\"raster\", pattern=\"lst_average_??\")['italy_LST_daily']\n\nprint(tmin,tmax,tavg)\n\n\n# Estimate temperature related bioclimatic variables\ngs.run_command(\"r.bioclim\", \n               tmin=tmin, \n               tmax=tmax,\n               tavg=tavg, \n               output=\"worldclim_\") \n\n\n# List output maps\ngs.list_grouped(type=\"raster\", pattern=\"worldclim*\")['italy_LST_daily']\n\nLet’s have a look at some of the maps we just created\n\n# Display raster map with interactive class\nbio_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nbio_map.add_raster(\"worldclim_bio01\")\nbio_map.add_raster(\"worldclim_bio02\")\nbio_map.add_layer_control(position = \"bottomright\")\nbio_map.show()\n\n\n\nSpring warming\nWe define spring warming as the velocity with which temperature increases from winter into spring and we calculate it as slope(daily Tmean February-March-April). We will use t.rast.aggregate.\n\n# Define list of months\nmonths=['{0:02d}'.format(m) for m in range(2,5)]\n\n\n# Annual spring warming\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_spring_warming\",\n               basename=\"spring_warming\",\n               suffix=\"gran\",\n               method=\"slope\",\n               granularity=\"1 years\",\n               where=f\"strftime('%m',start_time)='{months[0]}' or strftime('%m',start_time)='{months[1]}' or strftime('%m', start_time)='{months[2]}'\")\n\n\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", input=\"annual_spring_warming\")\n\n\n# Average spring warming\ngs.run_command(\"t.rast.series\",\n               input=\"annual_spring_warming\",\n               output=\"avg_spring_warming\",\n               method=\"average\")\n\n\n# Display raster map with interactive class\nauc_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nauc_map.add_raster(\"avg_spring_warming\")\nauc_map.add_layer_control(position = \"bottomright\")\nauc_map.show()\n\n\n\nAutumnal cooling\nWe define autumnal cooling as the velocity with which temperature decreases from summer into fall and we calculate it as slope(daily Tmean August-September-October).\n\n# Define list of months\nmonths=['{0:02d}'.format(m) for m in range(8,11)]\n\n\n# Annual autumnal cooling\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_autumnal_cooling\",\n               basename=\"autumnal_cooling\",\n               suffix=\"gran\",\n               method=\"slope\",\n               granularity=\"1 years\",\n               where=f\"strftime('%m',start_time)='{months[0]}' or strftime('%m',start_time)='{months[1]}' or strftime('%m', start_time)='{months[2]}'\")\n\n\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", input=\"annual_autumnal_cooling\")\n\n\n# Average autumnal cooling\ngs.run_command(\"t.rast.series\",\n               input=\"annual_autumnal_cooling\",\n               output=\"avg_autumnal_cooling\",\n               method=\"average\")\n\n\n# Display raster map with interactive class\nspw_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nspw_map.add_raster(\"avg_autumnal_cooling\")\nspw_map.add_layer_control(position = \"bottomright\")\nspw_map.show()\n\n\n\nNumber of days with LSTmean &gt;= 20 and &lt;= 30\nMosquitoes (and virus they might carry) tend to thrive in a certain range of temperatures. Let’s assume this range is from 20 to 30 °C. Here, we’ll estimate the number of days within this range per year, and then, we’ll estimate the average along years. See t.rast.algebra manual for further details.\n\n# Keep only pixels meeting the condition\nexpression=\"tmean_higher20_lower30 = if(lst_daily &gt;= 20.0 && lst_daily &lt;= 30.0, 1, null())\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression, \n               basename=\"tmean_higher20_lower30\",\n               suffix=\"gran\",\n               nproc=7, \n               flags=\"n\")\n\n\n# Count how many times per year the condition is met\ngs.run_command(\"t.rast.aggregate\",\n               input=\"tmean_higher20_lower30\", \n               output=\"count_tmean_higher20_lower30\",\n               basename=\"tmean_higher20_lower30\",\n               suffix=\"gran\",\n               method=\"count\",\n               granularity=\"1 years\")\n\n\n# Check raster maps in the STRDS\ngs.run_command(\"t.rast.list\", \n               input=\"count_tmean_higher20_lower30\", \n               columns=\"name,start_time,min,max\")\n\n\n# Average number of days with LSTmean &gt;= 20 and &lt;= 30\ngs.run_command(\"t.rast.series\",\n               input=\"count_tmean_higher20_lower30\",\n               output=\"avg_count_tmean_higher20_lower30\",\n               method=\"average\")\n\n\n# Display raster map with interactive class\nh20_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nh20_map.add_raster(\"avg_count_tmean_higher20_lower30\")\nh20_map.add_layer_control(position = \"bottomright\")\nh20_map.show()\n\n\n\nNumber of consecutive days with LSTmean &lt;= -10.0\nLikewise, there are temperature thresholds that mark a limit to mosquito survival. Here, we’ll use the temperature lower limit to survival. Most importantly, we we’ll count the number of consecutive days with temperatures below this threshold.\nHere, we’ll use again the temporal algebra and we’ll recall the concept of topology that we defined at the beginning of the notebook. First, we need to create a STRDS of annual granularity that will contain only zeroes. This annual STRDS, that we call annual mask, will be the base to add 1 each time the condition of less than -10 °C in consecutive days is met. Finally, we estimate the median number of days with LST lower than -10 °C over the 5 years.\n\n# Create annual mask\ngs.run_command(\"t.rast.aggregate\",\n               input=\"lst_daily\",\n               output=\"annual_mask\",\n               basename=\"annual_mask\",\n               suffix=\"gran\",\n               granularity=\"1 year\",\n               method=\"count\")\n\n\n# Replace values by zero\nexpression=\"if(annual_mask, 0)\"\n\ngs.run_command(\"t.rast.mapcalc\",\n               input=\"annual_mask\",\n               output=\"annual_mask_0\",\n               expression=expression,\n               basename=\"annual_mask_0\")\n\n\n# Calculate consecutive days with LST &lt;= -10.0\nexpression=\"lower_m10_consec_days = annual_mask_0 {+,contains,l} if(lst_daily &lt;= -10.0 && lst_daily[-1] &lt;= -10.0 || lst_daily[1] &lt;= -10.0 && lst_daily &lt;= -10.0, 1, 0)\"\n\ngs.run_command(\"t.rast.algebra\",\n               expression=expression,\n               basename=\"lower_m10\",\n               suffix=\"gran\",\n               nproc=7)\n\n\n# Inspect values\ngs.run_command(\"t.rast.list\",\n               input=\"lower_m10_consec_days\",\n               columns=\"name,start_time,min,max\")\n\n\n# Median number of consecutive days with LST &lt;= -10\ngs.run_command(\"t.rast.series\",\n               input=\"lower_m10_consec_days\",\n               output=\"median_lower_m10_consec_days\",\n               method=\"median\")\n\n\n# Display raster map with interactive class\nlt10_map = gj.InteractiveMap(width = 500, use_region=True, tiles=\"OpenStreetMap\")\nlt10_map.add_raster(\"median_lower_m10_consec_days\")\nlt10_map.add_layer_control(position = \"bottomright\")\nlt10_map.show()\n\nWe have now derived many potentially relevant predictors for the mosquito habitat suitability and we could still derive some more, for example, the number of mosquito or virus cycles per year based on development temperature thresholds and growing degree days (GDD). This could be achieved with t.rast.accumulate and t.rast.accdetect.\nWe will now open a GRASS session from R and perform SDM there.\n\n:::"
  },
  {
    "objectID": "notebook_intro.html",
    "href": "notebook_intro.html",
    "title": "Intro to GRASS GIS",
    "section": "",
    "text": "When you open GRASS you’ll get both the terminal and the graphical user interface (GUI). You can use GRASS tools in either. It’s a matter of taste, task on hand and habit, too.\nGRASS GUI has a single window layout by default, but it is also possible to minimize and/or dock/undock the panels. On the right, you can find the data browser which allows you to navigate through your projects and data, and the layers panel showing displayed layers. The panel in the middle is the map display. You can add additional ones if you need. Finally, on the right there are multiple tabs where you can find a searchable tools’ tree similar to the Processing toolbox in QGIS, a console where you can type GRASS commands, the history of executed commands in case you want to re-run a task and a simple Python console where you can use the GRASS Python API.\nFrom the data panel you can manage several actions and, if you do not yet have imported data into your GRASS project, the software creates a project with demo data automatically."
  },
  {
    "objectID": "notebook_intro.html#grass-gis-general-stuff",
    "href": "notebook_intro.html#grass-gis-general-stuff",
    "title": "Intro to GRASS GIS",
    "section": "",
    "text": "GRASS GIS (Geographic Resources Analysis Support System), a FOSS suite used for geospatial data management and analysis, image processing, graphics and maps, spatial modeling, and visualization.\nFree and open source, you can use, modify, improve, share\nStrong user community, commercial support\nLarge amount of tools: 500+ core modules, 400+ addons\nGUI and CLI interfaces\nPython API and libraries\nConnection with R, QGIS, WPS, REST APIs, etc.\nDifferent data types supported: raster (including satellite imagery), 3D raster or voxel, vector and space-time datasets\n\n\n\nWhen you open GRASS you’ll get both the terminal and the graphical user interface (GUI). You can use GRASS tools in either. It’s a matter of taste, task on hand and habit, too.\nGRASS GUI has a single window layout by default, but it is also possible to minimize and/or dock/undock the panels. On the right, you can find the data browser which allows you to navigate through your projects and data, and the layers panel showing displayed layers. The panel in the middle is the map display. You can add additional ones if you need. Finally, on the right there are multiple tabs where you can find a searchable tools’ tree similar to the Processing toolbox in QGIS, a console where you can type GRASS commands, the history of executed commands in case you want to re-run a task and a simple Python console where you can use the GRASS Python API.\nFrom the Data catalog panel you can manage several actions and if you do not yet have imported data into your GRASS project, the software creates a project with demo data automatically.\n\n\n\n\n\n\n\n\n\nGRASS database (directory with projects): When running GRASS GIS for the first time, a folder named grassdata is automatically created. Depending on the operating system, it can be found in $HOME (*nix) or My Documents (MS Windows).\nProject: GRASS projects are simply folders storing your geospatial data with common coordinate reference system (CRS), ensuring consistency of your data.\nMapset: Data is further organized into subprojects called mapsets, which you can use to manage different subregions or analyses within a project. When creating a new project, GRASS GIS automatically creates a special mapset called PERMANENT which is used to store source datasets for your analysis that can be easily accessed from other mapsets.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/grass_database.html.\n\n\n\n\n\nA very useful concept when working with raster data is that of the computational region. It refers to the boundaries and spatial resolution of the analysis area. The computational region can be defined and modified with the tool g.region to the extent of a vector map, a raster or manually to some area of interest. The output raster maps will have an extent and spatial resolution equal to the computational region, while vector maps are always processed at their original extent.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor more details, see the wiki on Computational Region.\n\n\n\n\n\nGRASS has more than 500 tools for the most varied tasks:\n\n\n\nPrefix\nFunction class\nType of command\nExample\n\n\n\n\ng.*\ngeneral\ngeneral data management\ng.rename: renames map\n\n\nd.*\ndisplay\ngraphical output\nd.rast: display raster map\n\n\nr.*\nraster\nraster processing\nr.mapcalc: map algebra\n\n\nv.*\nvector\nvector processing\nv.clean: topological cleaning\n\n\ni.*\nimagery\nimagery processing\ni.pca: Principal Components Analysis on imagery group\n\n\nr3.*\nvoxel\n3D raster processing\nr3.stats: voxel statistics\n\n\ndb.*\ndatabase\ndatabase management\ndb.select: select value(s) from table\n\n\nps.*\npostscript\nPostScript map creation\nps.map: PostScript map creation\n\n\nt.*\ntemporal\nspace-time datasets\nt.rast.aggregate: raster time series aggregation\n\n\n\nExtensions or add-ons can be installed from the central GitHub repository or from other users’ GitHub (or similar repositories) using the command g.extension. For example:\n # install an extension from the GRASS GIS repository\n g.extension extension=r.hants\n \n # install an extension from another GitHub repository\n g.extension extension=r.change.stats \\\n   url=https://github.com/mundialis/r.change.stats"
  },
  {
    "objectID": "notebook_intro.html#grass",
    "href": "notebook_intro.html#grass",
    "title": "Intro to GRASS GIS",
    "section": "GRASS + ",
    "text": "GRASS + \nThere are different Python libraries delivered with GRASS GIS, we’ll use 2 of them:\n\ngrass.script which provides Python interface to launch GRASS GIS modules in scripts\ngrass.jupyter which offers classes and setup functions for running GRASS GIS in Jupyter Notebooks\n\nOther Python libraries delivered with GRASS GIS include: pygrass, the temporal framework, the testing framework, among others.\nWe can use Python within GRASS GUI, within Jupyter notebooks, or from our preferred IDE. See the options within the GUI:\n\n\n\n\n\n\n\nNote\n\n\n\nSee https://grass.osgeo.org/grass-stable/manuals/libpython/index.html for further details."
  },
  {
    "objectID": "notebook_intro.html#grass-through-rgrass-package",
    "href": "notebook_intro.html#grass-through-rgrass-package",
    "title": "Intro to GRASS GIS",
    "section": "GRASS +  through rgrass package",
    "text": "GRASS +  through rgrass package\nWe can use R within a GRASS GIS session or use GRASS GIS within an R session. We’ll explore this further in the last part of this session."
  },
  {
    "objectID": "notebook_intro.html#demo-session-overview",
    "href": "notebook_intro.html#demo-session-overview",
    "title": "Intro to GRASS GIS",
    "section": "Demo session overview",
    "text": "Demo session overview\nHabitat suitability mapping for the Asian tiger mosquito in Northern Italy based on variables derived from daily LST data\n\nGRASS\n\nImport species records\nCreate random background points\nCreate different environmental layers from daily LST data\n\nR\n\nRead data from GRASS into R\nModel species distribution\nModel evaluation\nVisualization of results\n\n\n\n\n\n\n\n\nData for the session\n\n\nRecords of Aedes albopictus (Asian tiger mosquito) in Northern Italy downloaded from GBIF\nAverage daily MODIS LST reconstructed by mundialis GmbH & Co. KG based on Metz et al. (2017):\n\n1 km spatial resolution\nConverted to Celsius degrees\n\n\n\n\n\nGet the sample location\n\nCreate a folder named grass_ncsu_2023\nWithin grass_ncsu_2023 create a folder named grassdata\nDownload and unzip eu_laea location with LST mapset and unzip within your grassdata folder\nDownload mosquito data and drop it within grass_ncsu_2023\n\nThe grass_ncsu_2023 folder’s tree should look like this:\n  grass_ncsu_2023/\n  ├── aedes_albopictus.gpkg\n  └── grassdata\n      └── eu_laea\n          ├── italy_LST_daily\n          └── PERMANENT"
  },
  {
    "objectID": "notebook_intro.html#other-very-useful-links",
    "href": "notebook_intro.html#other-very-useful-links",
    "title": "Intro to GRASS GIS",
    "section": "Other (very) useful links",
    "text": "Other (very) useful links\n\nGRASS intro workshop held at NCSU\nUnleash the power of GRASS GIS at US-IALE 2017\nTemporal data processing wiki\nGRASS GIS and R for time series processing wiki\nGRASS GIS temporal workshop at NCSU\nGRASS GIS course in Jena\nGRASS GIS course IRSAE\nGRASS GIS course in Argentina"
  },
  {
    "objectID": "notebook_intro.html#open-grass-for-the-first-time",
    "href": "notebook_intro.html#open-grass-for-the-first-time",
    "title": "Intro to GRASS GIS",
    "section": "",
    "text": "When you open GRASS you’ll get both the terminal and the graphical user interface (GUI). You can use GRASS tools in either. It’s a matter of taste, task on hand and habit, too.\nGRASS GUI has a single window layout by default, but it is also possible to minimize and/or dock/undock the panels. On the right, you can find the data browser which allows you to navigate through your projects and data, and the layers panel showing displayed layers. The panel in the middle is the map display. You can add additional ones if you need. Finally, on the right there are multiple tabs where you can find a searchable tools’ tree similar to the Processing toolbox in QGIS, a console where you can type GRASS commands, the history of executed commands in case you want to re-run a task and a simple Python console where you can use the GRASS Python API.\nFrom the data panel you can manage several actions and, if you do not yet have imported data into your GRASS project, the software creates a project with demo data automatically."
  },
  {
    "objectID": "notebook_intro.html#database",
    "href": "notebook_intro.html#database",
    "title": "Intro to GRASS GIS",
    "section": "Database",
    "text": "Database\n\nGRASS database (directory with projects): When running GRASS GIS for the first time, a folder named grassdata is automatically created. Depending on the operating system, it can be found in $HOME (*nix) or My Documents (MS Windows).\nProject: GRASS projects are simply folders storing your geospatial data with common coordinate reference system (CRS), ensuring consistency of your data.\nMapset: Data is further organized into subprojects called mapsets, which you can use to manage different subregions or analyses within a project. When creating a new project, GRASS GIS automatically creates a special mapset called PERMANENT which is used to store source datasets for your analysis that can be easily accessed from other mapsets.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMore info: https://grass.osgeo.org/grass-stable/manuals/grass_database.html."
  },
  {
    "objectID": "notebook_intro.html#computational-region",
    "href": "notebook_intro.html#computational-region",
    "title": "Intro to GRASS GIS",
    "section": "Computational region",
    "text": "Computational region\nA very useful concept when working with raster data is that of the computational region. It refers to the boundaries and spatial resolution of the analysis area. The computational region can be defined and modified with the tool g.region to the extent of a vector map, a raster or manually to some area of interest. The output raster maps will have an extent and spatial resolution equal to the computational region, while vector maps are always processed at their original extent.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor more details, see the wiki on Computational Region."
  },
  {
    "objectID": "notebook_intro.html#tools",
    "href": "notebook_intro.html#tools",
    "title": "Intro to GRASS GIS",
    "section": "Tools",
    "text": "Tools\nGRASS has more than 500 tools for the most varied tasks:\n\n\n\nPrefix\nFunction class\nType of command\nExample\n\n\n\n\ng.*\ngeneral\ngeneral data management\ng.rename: renames map\n\n\nd.*\ndisplay\ngraphical output\nd.rast: display raster map\n\n\nr.*\nraster\nraster processing\nr.mapcalc: map algebra\n\n\nv.*\nvector\nvector processing\nv.clean: topological cleaning\n\n\ni.*\nimagery\nimagery processing\ni.pca: Principal Components Analysis on imagery group\n\n\nr3.*\nvoxel\n3D raster processing\nr3.stats: voxel statistics\n\n\ndb.*\ndatabase\ndatabase management\ndb.select: select value(s) from table\n\n\nps.*\npostscript\nPostScript map creation\nps.map: PostScript map creation\n\n\nt.*\ntemporal\nspace-time datasets\nt.rast.aggregate: raster time series aggregation\n\n\n\nExtensions or add-ons can be installed from the central GitHub repository or from other users’ GitHub (or similar repositories) using the command g.extension. For example:\n # install an extension from the GRASS GIS repository\n g.extension extension=r.hants\n \n # install an extension from another GitHub repository\n g.extension extension=r.change.stats \\\n   url=https://github.com/mundialis/r.change.stats"
  },
  {
    "objectID": "notebook_ex_rs_grass.html#temporal-tools",
    "href": "notebook_ex_rs_grass.html#temporal-tools",
    "title": "Part 1: Processing data in GRASS",
    "section": "Temporal tools",
    "text": "Temporal tools\nGRASS temporal tools are named and organized following GRASS core naming scheme. In this way, we have:\n\nt.*: general tools to handle STDS of all types\nt.rast.*: tools that deal with STRDS\nt.rast3d.*: tools that deal with STR3DS\nt.vect.*: tools that deal with STVDS\n\n\nOther TGRASS notions\n\nTime can be defined as intervals (start and end time) or instances (only start time)\nTime can be absolute (e.g., 2017-04-06 22:39:49) or relative (e.g., 4 years, 90 days)\nGranularity is the greatest common divisor of the temporal extents (and possible gaps) of all maps in the space-time cube\n\n\n\n\n\n\n\nTopology refers to temporal relations between time intervals in a STDS.\n\n\n\n\n\n\n\n\nTGRASS framework and workflow"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo is a biologist. She holds a PhD in Biological Sciences and an MSc in Remote Sensing and GIS applications. She works as a researcher for CONICET and lecturer at Gulich Institute - Argentinian Space Agency (CONAE) in Córdoba, Argentina. Her research is focused on uncovering environmental drivers of vector-borne disease outbreaks. She is mostly interested in those environmental features that can be derived by means of satellite image analysis, remote sensing time series and GIS-based techniques.\nVerónica is part of the GRASS GIS Development team and currently serves as the PSC chair. She is a strong advocate for OSGeo and free and open source software for geo-spatial (FOSS4G). She was the Program Committee chair for FOSS4G 2021. Among other things, she has volunteered as a mentor for GRASS GIS in the Google Code-In contest introducing high school students into the Open Source world.\n\n\n\n\nRemote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software\n\n\n\n\n\nPhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005.\n:::"
  },
  {
    "objectID": "about.html#about",
    "href": "about.html#about",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Verónica Andreo is a biologist. She holds a PhD in Biological Sciences and an MSc in Remote Sensing and GIS applications. She works as a researcher for CONICET and lecturer at Gulich Institute - Argentinian Space Agency (CONAE) in Córdoba, Argentina. Her research is focused on uncovering environmental drivers of vector-borne disease outbreaks. She is mostly interested in those environmental features that can be derived by means of satellite image analysis, remote sensing time series and GIS-based techniques.\nVerónica is part of the GRASS GIS Development team and currently serves as the PSC chair. She is a strong advocate for OSGeo and free and open source software for geo-spatial (FOSS4G). She was the Program Committee chair for FOSS4G 2021. Among other things, she has volunteered as a mentor for GRASS GIS in the Google Code-In contest introducing high school students into the Open Source world."
  },
  {
    "objectID": "about.html#interests",
    "href": "about.html#interests",
    "title": "Verónica Andreo",
    "section": "",
    "text": "Remote sensing time series\nImage analysis\nGIS\nSDM\nVector-borne diseases\nFree and Open Source Software"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Verónica Andreo",
    "section": "",
    "text": "PhD in Biological Sciences. National University of Río Cuarto. 2012.\nMSc in Spatial Applications for Early Warning and Response to Emergencies. National University of Córdoba. 2015.\nBiologist. National University of Río Cuarto. 2005."
  }
]